from flask import Flask
from flask import request, jsonify, render_template
from flask_cors import CORS, cross_origin

import cv2
from imutils import face_utils
import numpy as np
import argparse
import imutils
import dlib
import math
from PIL import Image
from subprocess import call
import os
import array
import io
import base64 
import numpy as np
import tensorflow as tf
from tensorflow import keras
os.environ['TF_CPP_MIN_LOG_LEVEL'] = '2'

#Importing Haar cascade and DLIB's facial landmarks detector
face_cascade = cv2.CascadeClassifier('haarcascade_frontalface_default.xml')
predictor = dlib.shape_predictor("shape_predictor_68_face_landmarks.dat")

targetPoints = []

# Read map.txt -> Can be tuned!
# map.txt holds a collection of points which will be used to recognize a face
# map.txt holds a list of pairs between which will define a set of lines to be considered by recognizer
lines = [line.rstrip('\n') for line in open('map.txt')]
for line in lines:
	tempList = line.split()
	targetPoints.append(int(tempList[0]))

# Holds number of ratios as defined by the map
totalTargets = int(len(targetPoints))


app = Flask(__name__)
CORS(app)

@app.route('/train/', methods=['POST'])
def train_POST():
	tf.keras.backend.clear_session()
	
	API_KEY = request.form.get('API_KEY')
	# Check if API_KEY is correct
	API_KEY_CORRECT_FLAG = False
	lines = [line.rstrip('\n') for line in open('API_KEYS')]
	for line in lines:
		tempList = line.split()
		if(tempList[0] == API_KEY):
			API_KEY_CORRECT_FLAG = True

	if(API_KEY_CORRECT_FLAG == False):
		return jsonify(
			responseType = "ERROR",
			errorDescription = "API_KEY is invalid!"
		)


	incomingUserName = request.form.get('userName')


	print("[LOG] -> Started retrieving images...")

	incomingStream = request.form.get('stream')
	#print(incomingStream)
	splitted = incomingStream.split("[IMAGE_STREAM_DELIMITER]")
	print("[LOG] -> All images received")
	print("[LOG] -> No of images received : {}".format(len(splitted)))

	# Average out all the values:

	# Basically finds distance between 2 points
	# Arguments:
	# 	-> tempshape: DLIB's predictor which plots facial landmark points
	# 	-> point1 & point2: Points between which distance is to be found out
	def getDistance(tempshape, point1, point2):
		point1x = tempshape.part(point1).x
		point1y = tempshape.part(point1).y
		point2x = tempshape.part(point2).x
		point2y = tempshape.part(point2).y
					
		dx = (point2x - point1x) ** 2
		dy = (point2y - point1y) ** 2
		distance = math.sqrt(dx + dy)
		return distance

	#TOTAL LANDMARKS DETECTED ARE FROM 0-67
	totals = []
	counts = []
	for i in range(0, totalTargets):
		totals.append(0.0)
		counts.append(0)

	# Take in base64 string and return PIL image
	def stringToImage(base64_string):
		imgdata = base64.b64decode(base64_string)
		return Image.open(io.BytesIO(imgdata))

	# convert PIL Image to an RGB image( technically a numpy array ) that's compatible with opencv
	def toRGB(image):
		return cv2.cvtColor(np.array(image), cv2.COLOR_BGR2RGB)

	def stringToBase64(s):
		return base64.b64encode(s.encode('utf-8'))

	print("[LOG] -> Started analysing images...")
	curatedRatios = []

	for x in splitted :
		frame = toRGB(stringToImage(base64.decodestring(stringToBase64(x))))

		#Convert the frame to grayscale
		grayFrame = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)

		#Activating Haar cascade classifier to detect faces
		faces = face_cascade.detectMultiScale(grayFrame, scaleFactor = 1.5, minNeighbors = 5)

		for(x, y, w, h) in faces :
			#Cropping and resizing face area
			pillowImage = Image.fromarray(frame[y:y+h, x:x+w])

			#Resizing dimensions
			resizedHeight = 300
			resizedWidth = 300
			######

			faceCropped = np.array(pillowImage.resize((resizedHeight, resizedWidth), Image.ANTIALIAS))

			#Initialize dlib's rectangle to start plotting points over shape of the face
			dlibRect = dlib.rectangle(0, 0, resizedHeight, resizedWidth)
			shape = predictor(cv2.cvtColor(faceCropped, cv2.COLOR_BGR2GRAY), dlibRect)
			shapeCopy = shape
			shape = face_utils.shape_to_np(shape)

			baseLine = getDistance(shapeCopy, 28, 27)
		
			tempL = []
			for z in range(0, totalTargets):
				temp = getDistance(shapeCopy, targetPoints[z], 27)
				currentRatio = float(temp)/float(baseLine)

				tempL.append(currentRatio)
			curatedRatios.append(tempL)

		if(len(curatedRatios) == 5):
			break

	print("[LOG] -> All images analyzed.")

	print("[LOG] -> Calculating average...")
	if(len(curatedRatios) == 5):
		print("[LOG] -> Curated ratios are good.")
	else:
		return jsonify(
				responseType = "FAILURE",
				failureDescription = "For this to work, at least 50 photos should be sent such that a face will be clearly visible in each one of them."
			)

	print("[LOG] -> Calculation done.")
	#print(curatedRatios)

	ratiosToProcess = []
	temp = curatedRatios
	for x in temp:
	    ratiosToProcess.append(x)

	temp = [[5.238544076875618, 2.8698945792537827, 3.2793678214144477, 4.305226085191401, 5.926455377874343, 6.181410022614165, 7.369533153707342, 8.241395811082844, 1.0, 3.7948328215703127, 3.782858562461949, 3.6526914747144734, 1.5186303649193895, 2.69600278224826, 2.0986988497647254, 3.0200965194456098, 1.1747179205309823, 5.131171649367627, 4.993757918386515, 5.411078742441271, 6.126887657118332, 6.203846602343293, 6.217391304347826, 5.5653872256694426, 5.511973562344514, 5.062184200983611, 5.608864170033251, 6.808895549289489, 8.241395811082844, 8.218426435838277, 8.218426435838277, 8.218426435838277, 8.218426435838277, 8.218426435838277, 8.218426435838277, 8.218426435838277, 8.218426435838277, 8.218426435838277, 8.218426435838277, 8.218426435838277, 8.218426435838277, 5.926455377874343, 5.926455377874343, 5.926455377874343, 5.926455377874343, 5.926455377874343, 5.926455377874343, 3.61602189798813, 3.61602189798813, 3.61602189798813], [5.129882063078683, 2.9130434782608696, 3.141285542293642, 4.264417333996254, 5.9503300094341, 6.087267072823322, 7.466623908420194, 8.198506019097602, 1.0, 3.8231213803444537, 3.782858562461949, 3.6956521739130435, 1.458305202717254, 2.610144525183241, 2.0467134427721425, 2.9800851283815293, 1.235884382917556, 5.174095722021648, 5.085469868234236, 5.464613781477913, 6.137214875431785, 6.208263290267694, 6.217391304347826, 5.608864170033251, 5.603300404701751, 4.97555460901564, 5.522937220243623, 6.803201737067357, 8.198506019097602, 8.087424016407946, 8.087424016407946, 8.087424016407946, 8.087424016407946, 8.087424016407946, 8.087424016407946, 8.087424016407946, 8.087424016407946, 8.087424016407946, 8.087424016407946, 8.087424016407946, 8.087424016407946, 5.9503300094341, 5.9503300094341, 5.9503300094341, 5.9503300094341, 5.9503300094341, 5.9503300094341, 3.698719954331107, 3.698719954331107, 3.698719954331107], [5.363828964184521, 3.0, 3.323159404806226, 4.375221363939324, 6.213322130778867, 6.338424081324217, 7.704511933421312, 8.61600471158661, 1.0, 3.967325222550781, 3.909355170771731, 3.773822404034149, 1.5109791035086055, 2.730679690159198, 2.1222940963506822, 3.070117234685142, 1.2864519725531733, 5.363828964184521, 5.226482153655491, 5.625539459898582, 6.383248997853292, 6.445255798961713, 6.454705503777524, 5.772906224856917, 5.812852673029578, 5.183612129658603, 5.745461737624957, 7.045454545454546, 8.61600471158661, 8.5004861309698, 8.5004861309698, 8.5004861309698, 8.5004861309698, 8.5004861309698, 8.5004861309698, 8.5004861309698, 8.5004861309698, 8.5004861309698, 8.5004861309698, 8.5004861309698, 8.5004861309698, 6.213322130778867, 6.213322130778867, 6.213322130778867, 6.213322130778867, 6.213322130778867, 6.213322130778867, 3.7372372347444482, 3.7372372347444482, 3.7372372347444482], [5.1563457701480075, 2.913367924826253, 3.2279497727427104, 4.264417333996254, 5.869726245778254, 6.087577608065092, 7.311202787529427, 8.08567077202927, 1.0, 3.808507043175922, 3.782858562461949, 3.659671393307646, 1.4242034221007998, 2.653599046898631, 2.0467134427721425, 3.037260729838779, 1.2088207629963343, 5.131171649367627, 5.042353697714435, 5.411078742441271, 6.116852051260781, 6.203846602343293, 6.173913043478261, 5.5653872256694426, 5.555187973556799, 4.97194397022937, 5.5957045367638845, 6.76768145581148, 8.08567077202927, 8.0042521780649, 8.0042521780649, 8.0042521780649, 8.0042521780649, 8.0042521780649, 8.0042521780649, 8.0042521780649, 8.0042521780649, 8.0042521780649, 8.0042521780649, 8.0042521780649, 8.0042521780649, 5.869726245778254, 5.869726245778254, 5.869726245778254, 5.869726245778254, 5.869726245778254, 5.869726245778254, 3.6298489503898788, 3.6298489503898788, 3.6298489503898788], [5.234320701633324, 2.9106181668517683, 3.268200127818323, 4.344591085259141, 5.944713840170058, 6.147863565100835, 7.323907607384833, 8.041519616083086, 1.0, 3.804912415623524, 3.78003693702628, 3.6427752223757537, 1.4996855016214516, 2.6945087415873354, 2.078642517842145, 3.034394036675415, 1.2626716210644435, 5.170672012089316, 5.037594514306013, 5.4059715409801035, 6.163342636332187, 6.2412202483712464, 6.254960295788199, 5.5601343814356365, 5.549944755801884, 5.086793852527662, 5.594640292279746, 6.793587431444395, 8.041519616083086, 7.995399620678108, 7.995399620678108, 7.995399620678108, 7.995399620678108, 7.995399620678108, 7.995399620678108, 7.995399620678108, 7.995399620678108, 7.995399620678108, 7.995399620678108, 7.995399620678108, 7.995399620678108, 5.944713840170058, 5.944713840170058, 5.944713840170058, 5.944713840170058, 5.944713840170058, 5.944713840170058, 3.6407028141736695, 3.6407028141736695, 3.6407028141736695]]
	for x in temp:
	    ratiosToProcess.append(x)

	temp = [[5.8531759334815225, 3.1014165360987453, 3.2488842113538814, 4.527692569068709, 6.0002301981623365, 7.23443270578873, 8.550952258689481, 9.507775242150428, 1.0, 3.725379583166531, 3.9506625781797458, 3.798807605883633, 1.415189892183811, 2.685134028569378, 2.065234458884934, 3.390757668878856, 1.4498999774989245, 5.220285549227132, 5.10795068701671, 5.421972893260222, 6.351142934510737, 6.575107922984613, 6.643236913213534, 6.062747403392959, 6.0, 5.5585780605518735, 6.453616913849027, 7.995337038839632, 9.507775242150428, 9.534033252262581, 9.534033252262581, 9.534033252262581, 9.534033252262581, 9.534033252262581, 9.534033252262581, 9.534033252262581, 9.534033252262581, 9.534033252262581, 9.534033252262581, 9.534033252262581, 9.534033252262581, 6.0002301981623365, 6.0002301981623365, 6.0002301981623365, 6.0002301981623365, 6.0002301981623365, 6.0002301981623365, 3.7149838455066924, 3.7149838455066924, 3.7149838455066924], [5.855063445924486, 3.0488653808420665, 3.1293478041850853, 4.3636494433087085, 5.967916060020242, 7.228702763733535, 8.550952258689481, 9.403185072238154, 1.0, 3.624654679684856, 3.898221722360734, 3.697094573755562, 1.453705495796273, 2.5759190818079087, 2.001380738859664, 3.2603426590074314, 1.3012955720150041, 5.172440782300832, 5.0524869430204635, 5.370525247726157, 6.238580728239592, 6.414115993486597, 6.495429757514636, 5.967221699135188, 5.837817271655355, 5.556589836197631, 6.435399338105133, 7.9780430727540095, 9.403185072238154, 9.429148412184714, 9.429148412184714, 9.429148412184714, 9.429148412184714, 9.429148412184714, 9.429148412184714, 9.429148412184714, 9.429148412184714, 9.429148412184714, 9.429148412184714, 9.429148412184714, 9.429148412184714, 5.967916060020242, 5.967916060020242, 5.967916060020242, 5.967916060020242, 5.967916060020242, 5.967916060020242, 3.645173907741517, 3.645173907741517, 3.645173907741517], [5.607707556560011, 2.9966731345463287, 2.9970891946850284, 4.259066901660263, 5.684997976693788, 6.8866852632606905, 8.170563306049015, 8.944829515555012, 1.0, 3.5540009416524962, 3.8532947329852494, 3.6577386961177676, 1.2964559402415228, 2.5048581226216866, 1.9276178882735082, 3.110997306235011, 1.2363973084083455, 5.013945639196535, 4.950125316431802, 5.190630346260576, 5.968537626295801, 6.145574000896803, 6.221192963995076, 5.7193289109842205, 5.646485014365695, 5.2929162654926065, 6.158747808084938, 7.613644399850937, 8.944829515555012, 9.058551573429318, 9.058551573429318, 9.058551573429318, 9.058551573429318, 9.058551573429318, 9.058551573429318, 9.058551573429318, 9.058551573429318, 9.058551573429318, 9.058551573429318, 9.058551573429318, 9.058551573429318, 5.684997976693788, 5.684997976693788, 5.684997976693788, 5.684997976693788, 5.684997976693788, 5.684997976693788, 3.5962019310902242, 3.5962019310902242, 3.5962019310902242], [5.543975184637851, 3.0498763312485675, 3.046194633577426, 4.255259324671, 5.637645110683623, 7.012102114191604, 8.311275878778606, 9.115496109739901, 1.0, 3.5739428271407507, 3.807067846261071, 3.6221127464685132, 1.358450048277755, 2.5546398060496447, 1.9276178882735082, 3.1744773952836836, 1.310802993885067, 4.97424789738493, 4.846264983394615, 5.132168364317439, 6.010174249862953, 6.243001068728055, 6.320611100857202, 5.769037659022684, 5.694859212165304, 5.208136737769252, 6.187631456574802, 7.712088512648999, 9.115496109739901, 9.177930810650473, 9.177930810650473, 9.177930810650473, 9.177930810650473, 9.177930810650473, 9.177930810650473, 9.177930810650473, 9.177930810650473, 9.177930810650473, 9.177930810650473, 9.177930810650473, 9.177930810650473, 5.637645110683623, 5.637645110683623, 5.637645110683623, 5.637645110683623, 5.637645110683623, 5.637645110683623, 3.5962019310902242, 3.5962019310902242, 3.5962019310902242], [5.839022420361542, 3.054445921799349, 3.2014539633148527, 4.537318328895222, 5.891916618592223, 7.2251101075680495, 8.600715038238103, 9.5158418722358, 1.0, 3.6653653361010843, 3.9599798538898274, 3.7667447021227134, 1.3531536981244674, 2.6363115339722514, 2.0041508173326075, 3.3954507613240654, 1.341847240419154, 5.184678044642001, 5.112041078563402, 5.367388961676616, 6.238562942699841, 6.528225527036881, 6.609193630331411, 6.027866957340852, 5.898495042577642, 5.5545643929625905, 6.416737117527651, 8.01660326933043, 9.5158418722358, 9.607245649772324, 9.607245649772324, 9.607245649772324, 9.607245649772324, 9.607245649772324, 9.607245649772324, 9.607245649772324, 9.607245649772324, 9.607245649772324, 9.607245649772324, 9.607245649772324, 9.607245649772324, 5.891916618592223, 5.891916618592223, 5.891916618592223, 5.891916618592223, 5.891916618592223, 5.891916618592223, 3.69547151190357, 3.69547151190357, 3.69547151190357]]
	for x in temp:
	    ratiosToProcess.append(x)

	temp = [[6.295964998134279, 3.087720942468199, 3.5710750929639707, 4.9662780354882665, 7.103505741141693, 7.356181214587884, 8.71188310392735, 8.965684868131335, 1.0, 4.479736737478376, 4.408286480110118, 4.374480823392281, 1.5860214114335824, 2.8447818027319145, 2.2599151521341154, 3.440510631005499, 1.2559138456235228, 6.092923053855694, 6.0, 6.50535069222759, 6.595374824235917, 6.270368870584559, 6.231446688775533, 5.36752357035817, 5.410375675353202, 6.013901421646214, 6.711276861626413, 8.087154125875808, 8.965684868131335, 8.991748794964892, 8.991748794964892, 8.991748794964892, 8.991748794964892, 8.991748794964892, 8.991748794964892, 8.991748794964892, 8.991748794964892, 8.991748794964892, 8.991748794964892, 8.991748794964892, 8.991748794964892, 7.103505741141693, 7.103505741141693, 7.103505741141693, 7.103505741141693, 7.103505741141693, 7.103505741141693, 4.366696833661962, 4.366696833661962, 4.366696833661962], [6.543543009121239, 3.0498763312485675, 3.5857851806258565, 4.860395189334785, 7.443218138638126, 7.756422807138111, 9.365932855533616, 9.606730807510953, 1.0, 4.590459585051916, 4.51210618718011, 4.446972126881037, 1.587042293669347, 2.8817077231211803, 2.262675572884826, 3.3847243761116483, 1.3183909183039504, 6.121789707833214, 6.0424516502109595, 6.6341893874029685, 7.415021486206075, 7.293627868303725, 7.235269668923536, 6.52942696251768, 6.542590181593927, 6.225400466842962, 7.03464883908762, 8.650025586285366, 9.606730807510953, 9.557412811575778, 9.557412811575778, 9.557412811575778, 9.557412811575778, 9.557412811575778, 9.557412811575778, 9.557412811575778, 9.557412811575778, 9.557412811575778, 9.557412811575778, 9.557412811575778, 9.557412811575778, 7.443218138638126, 7.443218138638126, 7.443218138638126, 7.443218138638126, 7.443218138638126, 7.443218138638126, 4.469067976497294, 4.469067976497294, 4.469067976497294], [6.281231195924756, 3.047831492714131, 3.4286456469819937, 4.7071336535008435, 7.1396822299132925, 7.565013313531919, 9.171407373841681, 9.498785852324978, 1.0, 4.385705640497009, 4.30883798581821, 4.279802358687424, 1.475485464722875, 2.726063360669381, 2.1704200496724013, 3.3847243761116483, 1.381206238516431, 5.913760950406569, 5.843554754563018, 6.336570026500782, 7.0666580404282415, 6.991979730278716, 6.976447730947562, 6.320611100857202, 6.342077351874313, 5.94781965122441, 6.797755240461878, 8.436501857465714, 9.498785852324978, 9.4709162367793, 9.4709162367793, 9.4709162367793, 9.4709162367793, 9.4709162367793, 9.4709162367793, 9.4709162367793, 9.4709162367793, 9.4709162367793, 9.4709162367793, 9.4709162367793, 9.4709162367793, 7.1396822299132925, 7.1396822299132925, 7.1396822299132925, 7.1396822299132925, 7.1396822299132925, 7.1396822299132925, 4.311152388018568, 4.311152388018568, 4.311152388018568], [6.305600566459997, 3.0029079837887545, 3.355124119218482, 4.657335404212549, 7.093251332346852, 7.565013313531919, 9.106737523898284, 9.548667831514951, 1.0, 4.373178281216276, 4.318088151807816, 4.300727769996718, 1.521254240368913, 2.693392672778249, 2.124550707967026, 3.2555343249071074, 1.329691618571296, 5.9679108656003415, 5.842914587157504, 6.325540990929564, 7.005697716769766, 6.894285464776276, 6.8879525458814115, 6.226201573585031, 6.243001068728055, 5.974592923246214, 6.797755240461878, 8.368239445752396, 9.548667831514951, 9.52709746118474, 9.52709746118474, 9.52709746118474, 9.52709746118474, 9.52709746118474, 9.52709746118474, 9.52709746118474, 9.52709746118474, 9.52709746118474, 9.52709746118474, 9.52709746118474, 9.52709746118474, 7.093251332346852, 7.093251332346852, 7.093251332346852, 7.093251332346852, 7.093251332346852, 7.093251332346852, 4.327030392769402, 4.327030392769402, 4.327030392769402], [6.323244848522367, 3.1027522980741504, 3.5693600955511218, 4.7969833983199175, 7.174232590296228, 7.611056220760698, 9.25274335905348, 9.997375346167349, 1.0, 4.400527341578268, 4.382599949851913, 4.361116487388818, 1.6225278688154707, 2.877326106798095, 2.2360679774997902, 3.328265023446652, 1.346162953038226, 5.967221699135188, 5.886823942721295, 6.343962196734085, 7.223733137511999, 7.098556385803451, 7.0868721525139255, 6.396217805073929, 6.412393042413007, 6.055224674308428, 6.830424301066273, 8.482188032114987, 9.997375346167349, 10.020145453890732, 10.020145453890732, 10.020145453890732, 10.020145453890732, 10.020145453890732, 10.020145453890732, 10.020145453890732, 10.020145453890732, 10.020145453890732, 10.020145453890732, 10.020145453890732, 10.020145453890732, 7.174232590296228, 7.174232590296228, 7.174232590296228, 7.174232590296228, 7.174232590296228, 7.174232590296228, 4.338253333883382, 4.338253333883382, 4.338253333883382]]
	for x in temp:
	    ratiosToProcess.append(x)


	indicesToProcess = []
	for x in range(1, 21):
	    if(x <= 5):
	        indicesToProcess.append([0])
	    elif(x > 5 and x <= 10):
	        indicesToProcess.append([1])
	    elif(x > 10 and x <= 15):
	        indicesToProcess.append([2])
	    else:
	        indicesToProcess.append([3])

	print(indicesToProcess)


	X = np.array(ratiosToProcess)
	y = np.array(indicesToProcess)


	model = keras.Sequential()


	class EarlyStoppingByLossVal(keras.callbacks.Callback):
	    def __init__(self, monitor='loss', value=0.000001, verbose=0):
	        super(keras.callbacks.Callback, self).__init__()
	        self.monitor = monitor
	        self.value = value
	        self.verbose = verbose

	    def on_epoch_end(self, epoch, logs={}):
	        current = logs.get(self.monitor)
	        if current is None:
	            print("Early stopping requires %s available!" % self.monitor)
	            exit()

	        if current < self.value:
	            if self.verbose > 0:
	                print("Epoch %05d: early stopping THR" % epoch)
	            self.model.stop_training = True


	earlyStop = [EarlyStoppingByLossVal()]

	model.add(keras.layers.Dense(200, input_dim=50, activation='sigmoid'))
	model.add(keras.layers.Dense(100, activation='sigmoid'))
	model.add(keras.layers.Dense(50, activation='sigmoid'))
	model.add(keras.layers.Dense(4, activation='sigmoid'))

	model.compile(loss='sparse_categorical_crossentropy', optimizer='adam')

	model.fit(X, y, batch_size=1, epochs=100000, callbacks=earlyStop)

	currentPath = os.getcwd()
	os.chdir(currentPath + "/HOME:" + API_KEY + "/")
	model.save(incomingUserName + ".keras")
	os.chdir(currentPath + "/")


	return jsonify(
			responseType = "SUCCESS", 
			successDescription = "Model trained successfully."
		)

@app.route('/recognize/', methods=['POST'])
def recognize_POST():
	tf.keras.backend.clear_session()

	# Take in base64 string and return PIL image
	def stringToImage(base64_string):
		imgdata = base64.b64decode(base64_string)
		return Image.open(io.BytesIO(imgdata))

	# convert PIL Image to an RGB image( technically a numpy array ) that's compatible with opencv
	def toRGB(image):
		return cv2.cvtColor(np.array(image), cv2.COLOR_BGR2RGB)


	def stringToBase64(s):
		return base64.b64encode(s.encode('utf-8'))


	incomingImage = request.form.get('picture')
	decoded = toRGB(stringToImage(base64.decodestring(stringToBase64(incomingImage))))


	API_KEY = request.form.get('API_KEY')
	# Check if API_KEY is correct
	API_KEY_CORRECT_FLAG = False
	lines = [line.rstrip('\n') for line in open('API_KEYS')]
	for line in lines:
		tempList = line.split()
		if(tempList[0] == API_KEY):
			API_KEY_CORRECT_FLAG = True

	if(API_KEY_CORRECT_FLAG == False):
		return jsonify(
			responseType = "ERROR",
			errorDescription = "API_KEY is invalid!"
		)


	incomingUserName = request.form.get('userName')
	# Check if userName's keras model exists in HOME:API_KEY
	currentPath = os.getcwd()
	masterPath = currentPath + "/HOME:" + API_KEY + "/" + incomingUserName + ".keras"
	if not os.path.exists(masterPath):
		return jsonify(
			responseType = "ERROR",
			errorDescription = "Username is invalid!"
		)

	def recognizeFace(frame):
		
		print("[LOG] -> LOADING MODEL...")
		model = keras.models.load_model(masterPath)
		print("[LOG] -> MODEL LOADED.")

		# Basically finds distance between 2 points
		# Arguments:
		# 	-> tempshape: DLIB's predictor which plots facial landmark points
		# 	-> point1 & point2: Points between which distance is to be found out
		def getDistance(tempshape, point1, point2):
			point1x = tempshape.part(point1).x
			point1y = tempshape.part(point1).y
			point2x = tempshape.part(point2).x
			point2y = tempshape.part(point2).y
						
			dx = (point2x - point1x) ** 2
			dy = (point2y - point1y) ** 2
			distance = math.sqrt(dx + dy)
			return distance

		#Convert the frame to grayscale
		grayFrame = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)

		#Activating Haar cascade classifier to detect faces
		faces = face_cascade.detectMultiScale(grayFrame, scaleFactor = 1.5, minNeighbors = 5)

		print("[LOG] -> STARTING FACE DETECTION.")
		for(x, y, w, h) in faces :
			print("[LOG] -> FOUND A FACE.")
			pillowImage = Image.fromarray(frame[y:y+h, x:x+w])
			#Resizing dimensions
			resizedHeight = 300
			resizedWidth = 300
			######
			faceCropped = np.array(pillowImage.resize((resizedHeight, resizedWidth), Image.ANTIALIAS))

			#Initialize dlib's rectangle to start plotting points over shape of the face
			dlibRect = dlib.rectangle(0, 0, resizedHeight, resizedWidth)
			shape = predictor(cv2.cvtColor(faceCropped, cv2.COLOR_BGR2GRAY), dlibRect)
			shapeCopy = shape
			shape = face_utils.shape_to_np(shape)

			for (name, (i, j)) in face_utils.FACIAL_LANDMARKS_IDXS.items():
				baseLine = getDistance(shapeCopy, 28, 27)
				ratios = []

				for x in targetPoints:
					currentLine = getDistance(shapeCopy, x, 27)
					currentRatio = float(currentLine)/float(baseLine)
					ratios.append(currentRatio)

				foundFlag = 0

				print("[LOG] -> SENDING FACE TO KERAS...")

				# Keras neural net
				npratios = []
				npratios.append(ratios)
				npratios = np.array(npratios)

				import time

				start_time = time.time()
				kerasOutput = model.predict(npratios)
				detection_time = time.time()-start_time
				print("\n--- Detection time: %s seconds ---" % (time.time() - start_time))
				print("\nKERAS O/P: {}".format(kerasOutput))
	
				maxValue = kerasOutput[0][0]

				sumX = 0
				for value in kerasOutput[0]:
					sumX = sumX + value
					if(maxValue < value):
						maxValue = value

				if(maxValue == kerasOutput[0][0] and maxValue > 0.05):
					confidence = kerasOutput[0][0]
					print("[LOG] -> RETURNING SUCCESS...")
					print("\nKERAS O/P: {}".format(kerasOutput))
					return jsonify(
						responseType = "SUCCESS",
						successDescription = "Face recognized successfully",
						confidencePercentage = str(confidence),
						detectionTime = str(detection_time)
					)
				else:
					print("[LOG] -> RETURNING FAILURE...")
					print("\nKERAS O/P: {}".format(kerasOutput))
					return jsonify(
						responseType = "FAILURE",
						failureDescription = "Face not recognized",
					)
		
		print("[LOG] -> RETURNING FAILURE...")
		return jsonify(
			responseType = "FAILURE",
			failureDescription = "Face not detected.",
			possibleSolution = "Move a bit away from camera. Align yourself properly in front of the camera."
		)

	# decoded contains image which can be read by opencv
	result = recognizeFace(decoded)
	return result

if __name__ == '__main__':
    app.run(threaded=True)